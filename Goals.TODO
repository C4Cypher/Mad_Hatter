Outline
Current goals
get a repl running
		get parsing working
			Define TOP level constructs 
				definitions for module, program and ... 'library'? <- I am here
					method dispatch for top level atoms
				finish mh_term
					implement unification
						define environments/symbol substitution
							scope
							finish substitutions 
						hash out higher order types 
							further define and integerate type system
									merge type system into mh_term 
							define clauses
							mode system
								implement inst trees?
 
compile to native at runtime
	
	

types as terms
value terms!?
types as *relations*? promising

I can't proceed until I finally hash out higher order terms, relations
I am at a point where I could get parsing working.

Type notes:

Currently my mh_type structure as written is largely reduntant with mh_term in structure
It was suggested that I examine CUE to help me conceptualize types as terms

X > Y :- X = >Y, Y = <X.

X + Y = Z :- Z = X + Y, X = Z - Y, Y = Z - X. 

How to handle mr_type(type_desc)?  
* mr_term(univ) where typeof = type_desc?
* or keep my original mr_type/1 constructor

Conjecture:
* Types are constraints when they aren't grounded by the target type checker
	- examples being raw C types or Mercury types, primitive types
* Constraints are neither completely semantically ground nor free
	- akin to a variable being bound to a non-ground structure `X = foo(Y)`
* Non primitive types can be represented by terms
* Terms representing types and terms representing type constraints are distinct

	
			
Higher order constructs:
	* A relation takes a substitution as input and returns a substitution
	* A predicate takes a term as input and returns a substitution
	* A function takes a term as input and returns a term
					
HO Notes:

I just realized I can implement constraint solving (and thus types) by making
'constraint terms' ... 

Id' have to re-think the rules to unification.
* A free variable unified with a constraint binds the variable to the constraint the same as if bound to a ground value.
* A constraint unifies with another constraint to produce a new constraint, and may result in constraint propogation, resulting in more unifications
* A constraint unifying with a ground value either fails if the constraint is not met, or results in a binding to said ground value if it succeeds

And I suspect I can use relations as the mechanism for defining constraints

I've been struggling to define relations in anything but a general sense, 
I know they're something of a superclass to both predicates and functions,
Depending on the mode, i.e. information flow of the arguments and return value

A function is a relation with all input arguments and unifies with an output 

A predicate accepts substitutions and returns new substitutions 
and with constraints may *replace* substitutions

A predicate can also, under the right modes, be reduced to a function, either
of the form pred(in, in, in, out) => func(in, in, in) -> out OR 
pred(args) => func(substitutions) -> substitutions

Loose ideas:
Relations can resolve to predicates or functions
Relations propogate constraints if they can't resolve to a higher order call?
Constraints == types?
Constraints ARE higher order constructts?

